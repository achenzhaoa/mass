#!/usr/bin/env node
var fs = require('fs'),
  globule = require('globule'),
  path = require('path'),
  mcss = require('../'),
  _ = require('../lib/helper/util'),
  color = require('../lib/helper/color'),
  promise = require('../lib/helper/promise'),
  cwd = process.cwd(),
  version = fs.readFileSync(path.join(__dirname, '../package.json'), 'utf8').version;

var isWin = process.platform === 'win32';


var program = require('commander')
  .version(version || '0.0.1')
  .usage('[options] <file>')
  .option('-f, --format <n>', 'the outport format, 1: common | 2: compress | 3:online', parseInt)
  .option('-w, --watch', 'watch the file change and build')
  .option('-s, --sourcemap', 'generate the sourcemap')
  .option('-o, --outport <filename>', 'the outport filename or dirname')
  .option('-i, --indent <indent>', 'the indent string default "\\t"')
  .option('-t, --test', 'just for test , forbit underscore file')
  .parse(process.argv);

if(!program.args.length) throw 'the <file> arguments to build is required'



var watch = program.watch;
var sourceMap = program.sourcemap;
if(program.outport)  var outport = path.resolve(cwd, program.outport);

var file = path.resolve(cwd, program.args[0]);

var stat = fs.statSync(file); 
// is directory
if(stat.isDirectory()){
  var files = globule.find(path.join(file , '**/*.mcss'))
  .filter(function(item){
    if(program.test) return path.basename(item).indexOf('_') !== 0
    return true;
  })
  .map(function(rpath){
    return path.resolve(cwd, rpath);
  });
  var inputDir = file;
}else if(stat.isFile()){
  var files = [file];
}else{
  throw 'unsupported <file> type'
}

if(!files.length) throw 'no matched mcss file';



var building;
function build(fullpath, first){
  var imports = [];
  if(building){
    console.log('is busy building')
    return;
  }
  // is in building step
  building = true;
  var start = Date.now();
  var promises = files.map(function(file){
    var fullpath = path.resolve(cwd, file);
    if(inputDir){
      var rpath = path.relative(inputDir, file);
      var dest = path.join(outport, rpath).replace(/\.mcss/,'.css');
    }else{
      if(outport && !/\.css$/.test(outport)){
        dest = path.join(outport, path.basename(file))
      }else{
        dest = outport;
      }
      
    }
    var instance = mcss({
      format: program.format,
      filename: fullpath,
      dest: dest,
      sourceMap: sourceMap,
      // walkers: [{
      //   'url': function(ast){
      //       console.log(ast)
      //   }
      // }]
    // @TODO remove
    });
    return instance.include(path.join(__dirname, '../test/mcss/include'))
     .translate().done(function(content){
      if(!outport) return console.log(file + '\n' +content);
      _.writeFile(dest, content, function(err){
        if(err) return console.log(err)
        console.log(dest + ' writed')
      })
    }).fail(function(err){
      mcss.error.format(err)
      console.log(err.message);
    }).always(function(){
      Object.keys(instance.get('imports')).forEach(function(ipt){
        if(!~imports.indexOf(ipt)) imports.push(ipt);
      })
    })
  }).filter(promise.isPromise);
  mcss.promise.when.apply(mcss.promise, promises).always(function(){
    console.log(color('building complete in ' + (Date.now() - start) + 'ms', 'green'))
    building = false;
    if(first && watch){
      var watchers = _.slice(files);
      imports.forEach(function(file){
        if(!~watchers.indexOf(file)){
          watchers.push(file); 
        }
      })
      watchers.forEach(function(fullpath){
        _.watch(fullpath, _.throttle(build, 300))
      })
    }
  })
}


build(null,true);










